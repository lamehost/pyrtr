"""Interface towards the rpki-client JSON file"""

import base64
import hashlib
import logging
import os
from datetime import datetime, timezone
from ipaddress import ip_network
from typing import Tuple, TypedDict

import aiofiles
import orjson

from .pdu import ipv4_prefix, ipv6_prefix, router_key

logger = logging.getLogger(__name__)


class JSONMetadata(TypedDict):
    """File metadata"""

    buildmachine: str
    buildtime: str
    elapsedtime: int
    usertime: int
    systemtime: int
    roas: int
    failedroas: int
    invalidroas: int
    aspas: int
    failedaspas: int
    invalidaspas: int
    bgpsec_pubkeys: int
    certificates: int
    invalidcertificates: int
    nonfunctionalcas: int
    taks: int
    tals: int
    invalidtals: int
    talfiles: list[str]
    manifests: int
    failedmanifests: int
    crls: int
    gbrs: int
    repositories: int
    vrps: int
    uniquevrps: int
    vsps: int
    uniquevsps: int
    vaps: int
    uniquevaps: int
    cachedir_new_files: int
    cachedir_del_files: int
    cachedir_del_dirs: int
    cachedir_superfluous_files: int
    cachedir_del_superfluous_files: int


class ROA(TypedDict):
    """RPKI ROA"""

    asn: int
    prefix: str
    maxLength: int
    ta: str
    expires: int


class BGPSecKey(TypedDict):
    """BGPSec key"""

    asn: int
    ski: str
    pubkey: str
    ta: str
    expires: int


class NonFuncCA(TypedDict):
    """Non functional CA"""

    location: str
    ta: str
    caRepository: str
    rpkiManifest: str
    ski: str


class ASPA(TypedDict):
    """ASPA object"""

    customer_asid: int
    expires: int
    providers: list[int]


class JSONContent(TypedDict):
    """Defines the fields in the JSON file"""

    metadata: JSONMetadata
    roas: list[ROA]
    bgpsec_keys: list[BGPSecKey]
    nonfunc_cas: list[NonFuncCA]
    aspas: list[ASPA]


class JSONDiffs(TypedDict):
    """Defines the data structure representing the objects in the JSON file"""
    prefixes: list[bytes]
    router_keys: list[bytes]

class JSON(TypedDict):
    """Defines the data structure representing the JSON file"""

    content: JSONContent
    hash: str
    timestamp: float
    diffs: JSONDiffs


class RPKIClient:
    """
    Interface for the JSON file as generated by rpki_client.
    """

    serial: int = 0
    json: dict[int, JSON] = {}
    prefixes: list[bytes] = []
    router_keys: list[bytes] = []

    def serialize_bgpsec_key(self, bgpsec_key: BGPSecKey, flags: int) -> bytes:
        """
        Serialize the BGPSec Key to bytes

        Arguments:
        ----------
        bgpsec_key: BGPSec Key
            The BGPSec Key to serialize

        flags: int
            Either 0 for withdrawal or 1 for advertisement

        Returns:
        --------
        bytes: The serialized BGPSec Key
        """
        ski = base64.b16decode(bgpsec_key['ski'])
        pubkey = base64.b64decode(bgpsec_key['pubkey'])

        return router_key.serialize(
            flags=flags,
            ski=ski,
            spki=pubkey,
            asn=bgpsec_key['asn'],
        )

    def serialize_prefixes(self, roa: ROA, flags: int) -> bytes:
        """
        Serialize the ROA to bytes

        Arguments:
        ----------
        roa: ROA
            The ROA to serialize

        flags: int
            Either 0 for withdrawal or 1 for advertisement

        Returns:
        --------
        bytes: The serialized ROA
        """
        prefix = ip_network(roa["prefix"])
        if prefix.version == 4:
            return ipv4_prefix.serialize(
                prefix=prefix.network_address.packed,
                prefix_length=prefix.prefixlen,
                flags=flags,
                max_length=roa["maxLength"],
                asn=roa["asn"],
            )

        return ipv6_prefix.serialize(
            prefix=prefix.network_address.packed,
            prefix_length=prefix.prefixlen,
            flags=flags,
            max_length=roa["maxLength"],
            asn=roa["asn"],
        )

    def purge(self, expire: int = 7200):
        """
        Delete expired JSON files

        Arguments:
        ----------
        expire: int
            The amount of seconds after which a file is purged. Default: 7200
        """
        self.json = {
            _serial: _json
            for _serial, _json in self.json.items()
            if _json["timestamp"] > datetime.now(timezone.utc).timestamp() - expire
        }

    async def load(self, path: str | os.PathLike[str]) -> bool:
        """
        Loads the content of the file. Ignores files that have been already loaded.

        Arguments:
        ----------
        path: str | os.PathLike[str]
            Path to the file

        Returns:
        --------
        bool: True if the file was loaded, False if it was ignored
        """
        async with aiofiles.open(path, mode="rb") as file:
            data: bytes = await file.read()

        new_json_hash = hashlib.sha256(data).hexdigest()
        new_json: JSONContent = orjson.loads(data)  # pylint: disable=no-member

        # Check if the new and the current file are the same
        try:
            if new_json_hash == self.json[self.serial]["hash"]:
                return False
        except KeyError:
            pass

        diffs: JSONDiffs = {"prefixes": [], "router_keys": []}
        for _serial, _json in self.json.items():
            # Generate hashabale data structures
            old_roas: dict[Tuple[int, str, int], ROA] = {
                key: roa
                for roa in _json["content"]["roas"]
                if (key := (roa["asn"], roa["prefix"], roa["maxLength"]))
            }

            new_roas: dict[Tuple[int, str, int], ROA] = {
                key: roa
                for roa in new_json["roas"]
                if (key := (roa["asn"], roa["prefix"], roa["maxLength"]))
            }

            old_bgpsec_keys: dict[Tuple[int, str, str], BGPSecKey] = {
                key: bgpsec_key
                for bgpsec_key in _json["content"]["bgpsec_keys"]
                if (key := (bgpsec_key["asn"], bgpsec_key["ski"], bgpsec_key["pubkey"]))
            }

            new_bgpsec_keys: dict[Tuple[int, str, str], BGPSecKey] = {
                key: bgpsec_key
                for bgpsec_key in new_json["bgpsec_keys"]
                if (key := (bgpsec_key["asn"], bgpsec_key["ski"], bgpsec_key["pubkey"]))
            }

            # Calculate changes
            removed_roa_keys: set[Tuple[int, str, int]] = set(old_roas) - set(new_roas)
            diffs["prefixes"] = [
                self.serialize_prefixes(roa, 0)
                for key in removed_roa_keys
                if (roa := old_roas[key])
            ]

            added_roa_keys: set[Tuple[int, str, int]] = set(new_roas) - set(old_roas)
            diffs["prefixes"] = diffs["prefixes"] + [
                self.serialize_prefixes(roa, 1) for key in added_roa_keys if (roa := new_roas[key])
            ]

            removed_bgpsec_key_keys: set[Tuple[int, str, str]] = (
                set(old_bgpsec_keys) - set(new_bgpsec_keys)
            )
            diffs["router_keys"] = [
                self.serialize_bgpsec_key(bgpsec_key, 0)
                for key in removed_bgpsec_key_keys
                if (bgpsec_key := old_bgpsec_keys[key])
            ]

            added_bgpsec_key_keys: set[Tuple[int, str, str]] = (
                set(new_bgpsec_keys) - set(old_bgpsec_keys)
            )
            diffs["router_keys"] = diffs["router_keys"] + [
                self.serialize_bgpsec_key(bgpsec_key, 1)
                for key in added_bgpsec_key_keys
                if (bgpsec_key := new_bgpsec_keys[key])
            ]

            # Add a new list of changes
            self.json[_serial]["diffs"] = diffs

        # Update the list of prefixes
        self.prefixes = [self.serialize_prefixes(roa, 1) for roa in new_json["roas"]]
        self.router_keys = [
            self.serialize_bgpsec_key(bgpsec_key, 1) for bgpsec_key in new_json["bgpsec_keys"]
        ]

        # Save new JSON
        self.serial = self.serial + 1
        self.json[self.serial] = JSON(
            content=new_json,
            hash=new_json_hash,
            timestamp=datetime.now(timezone.utc).timestamp(),
            diffs={"prefixes": [], "router_keys": []},
        )
        logger.info("Serial changed to: %d", self.serial)

        return True
