"""Interface towards the rpki-client JSON file"""

import base64
import logging
import os
from collections.abc import Generator
from datetime import datetime, timedelta, timezone
from ipaddress import ip_network
from typing import TypedDict

import orjson

from pyrtr import prometheus
from pyrtr.rtr.pdu import ipv4_prefix, ipv6_prefix, router_key

logger = logging.getLogger(__name__)


class JSONMetadata(TypedDict):
    """File metadata"""

    buildmachine: str
    buildtime: str
    elapsedtime: int
    usertime: int
    systemtime: int
    roas: int
    failedroas: int
    invalidroas: int
    aspas: int
    failedaspas: int
    invalidaspas: int
    bgpsec_pubkeys: int
    certificates: int
    invalidcertificates: int
    nonfunctionalcas: int
    taks: int
    tals: int
    invalidtals: int
    talfiles: list[str]
    manifests: int
    failedmanifests: int
    crls: int
    gbrs: int
    repositories: int
    vrps: int
    uniquevrps: int
    vsps: int
    uniquevsps: int
    vaps: int
    uniquevaps: int
    cachedir_new_files: int
    cachedir_del_files: int
    cachedir_del_dirs: int
    cachedir_superfluous_files: int
    cachedir_del_superfluous_files: int


class ROA(TypedDict):
    """RPKI ROA"""

    asn: int
    prefix: str
    maxLength: int
    ta: str
    expires: int


class BGPSecKey(TypedDict):
    """BGPSec key"""

    asn: int
    ski: str
    pubkey: str
    ta: str
    expires: int


class NonFuncCA(TypedDict):
    """Non functional CA"""

    location: str
    ta: str
    caRepository: str
    rpkiManifest: str
    ski: str


class ASPA(TypedDict):
    """ASPA object"""

    customer_asid: int
    expires: int
    providers: list[int]


class JSONContent(TypedDict):
    """Defines the fields in the JSON file"""

    metadata: JSONMetadata
    roas: dict[str, ROA]
    bgpsec_keys: dict[str, BGPSecKey]
    nonfunc_cas: list[NonFuncCA]
    aspas: dict[str, ASPA]


class JSONDiffs(TypedDict):
    """Defines the data structure representing the objects in the JSON file"""

    vrps: list[bytes]
    router_keys: list[bytes]


class JSON(TypedDict):
    """Defines the data structure representing the JSON file"""

    content: JSONContent
    hash: str
    timestamp: float
    diffs: JSONDiffs


class RPKIClient:
    """
    Interface for the JSON file as generated by rpki_client.

    Arguments:
    ----------
    version: int
        The version identifier
    """

    # Serial equals 0 means no data is available
    serial: int = 0
    json_file: str | os.PathLike[str]
    expire: int
    versions: int

    def __init__(self, version: int, json_file: str | os.PathLike[str], expire: int = 7200):
        self.json: dict[int, JSON] = {}
        self.vrps: list[bytes] = []
        self.router_keys: list[bytes] = []
        self.last_update: str | None = None

        self.version = version
        self.json_file = json_file
        self.expire = expire

    def calculate_roa_diffs(
        self, old_roas: dict[str, ROA], new_roas: dict[str, ROA]
    ) -> Generator[bytes]:
        """
        Calculates the differences in the ROAs between the old and the new JSON file and yields
        prefix PDUs.

        Arguments:
        ----------
        old_roas: dict[str, ROA]
            ROAs in the old JSON file
        new_roas: dict[str, ROA]
            ROAs in the new JSON file

        Returns:
        --------
        Generator[bytes]: Yields serialized prefix PDUs
        """
        old_roas_keys: set[str] = set(old_roas.keys())
        new_roas_keys: set[str] = set(new_roas.keys())

        # Generate hashabale data structures
        # Yield changes
        removed_roa_keys: set[str] = old_roas_keys - new_roas_keys
        for key in removed_roa_keys:
            yield self.serialize_vrp(old_roas[key], 0)

        added_roa_keys: set[str] = new_roas_keys - old_roas_keys
        for key in added_roa_keys:
            yield self.serialize_vrp(new_roas[key], 1)

    def calculate_bgpsec_key_diffs(
        self,
        old_bgpsec_keys: dict[str, BGPSecKey],
        new_bgpsec_keys: dict[str, BGPSecKey],
    ) -> Generator[bytes]:
        """
        Calculates the differences in the BGPSec Keys between the old and the new JSON file and
        yields prefix PDUs.

        Arguments:
        ----------
        old_roas: dict[str, BGPSecKey]
            BGPSec Keys in the old JSON file
        new_roas: dict[str, BGPSecKey]
            BGPSec Keys in the new JSON file

        Returns:
        --------
        Generator[bytes]: Yields serialized router key PDUs
        """
        # Generate hashabale data structures
        old_bgpsec_key_keys: set[str] = set(old_bgpsec_keys.keys())
        new_bgpsec_key_keys: set[str] = set(new_bgpsec_keys.keys())

        # Yield changes
        removed_bgpsec_key_keys: set[str] = old_bgpsec_key_keys - new_bgpsec_key_keys
        for key in removed_bgpsec_key_keys:
            yield self.serialize_bgpsec_key(old_bgpsec_keys[key], 0)

        added_bgpsec_key_keys: set[str] = new_bgpsec_key_keys - old_bgpsec_key_keys
        for key in added_bgpsec_key_keys:
            yield self.serialize_bgpsec_key(new_bgpsec_keys[key], 1)

    def serialize_bgpsec_key(self, bgpsec_key: BGPSecKey, flags: int) -> bytes:
        """
        Serialize the BGPSec Key to bytes

        Arguments:
        ----------
        bgpsec_key: BGPSec Key
            The BGPSec Key to serialize

        flags: int
            Either 0 for withdrawal or 1 for advertisement

        Returns:
        --------
        bytes: The serialized BGPSec Key
        """
        # This is not stated anywhere in the rpki-client docs
        ski = base64.b16decode(bgpsec_key["ski"], casefold=True)
        pubkey = base64.b64decode(bgpsec_key["pubkey"])

        return router_key.serialize(
            version=self.version,
            flags=flags,
            ski=ski,
            spki=pubkey,
            asn=bgpsec_key["asn"],
        )

    def serialize_vrp(self, roa: ROA, flags: int) -> bytes:
        """
        Serialize the ROA to bytes

        Arguments:
        ----------
        roa: ROA
            The ROA to serialize

        flags: int
            Either 0 for withdrawal or 1 for advertisement

        Returns:
        --------
        bytes: The serialized ROA
        """
        prefix = ip_network(roa["prefix"])
        if prefix.version == 4:
            return ipv4_prefix.serialize(
                version=self.version,
                prefix=prefix.network_address.packed,
                prefix_length=prefix.prefixlen,
                flags=flags,
                max_length=roa["maxLength"],
                asn=roa["asn"],
            )

        return ipv6_prefix.serialize(
            version=self.version,
            prefix=prefix.network_address.packed,
            prefix_length=prefix.prefixlen,
            flags=flags,
            max_length=roa["maxLength"],
            asn=roa["asn"],
        )

    def purge(self):
        """
        Delete expired JSON files

        Arguments:
        ----------
        expire: int
            The amount of seconds after which a file is purged. Default: 7200
        """
        self.json = {
            _serial: _json
            for _serial, _json in self.json.items()
            if _json["timestamp"] > datetime.now(timezone.utc).timestamp() - self.expire
        }

    def _reduce_roas(self, roas: list[ROA]) -> dict[str, ROA]:
        """
        Reduces a list of ROAs into a dict of unique and valid ROAs.

        Arguments:
        ----------
        roas: list[ROA]
            The ROAs to reduce

        Returns:
        --------
        dict[str, ROA]: The reduced ROAs
        """
        current_timestamp = datetime.now(timezone.utc).timestamp()

        reduced_roas: dict[str, ROA] = {}
        for roa in roas:
            if current_timestamp >= roa["expires"]:
                continue
            key = f'{roa["asn"]}|{roa["prefix"]}|{roa["maxLength"]}'
            reduced_roas[key] = roa

        return reduced_roas

    def _reduce_bgpsec_keys(self, bgpsec_keys: list[BGPSecKey]) -> dict[str, BGPSecKey]:
        """
        Reduces a list of BGPSec Keys into a dict of unique and valid BGPSec Keys.

        Arguments:
        ----------
        roas: list[BGPSecKey]
            The BGPSec Keys to reduce

        Returns:
        --------
        dict[str, BGPSecKey]: The reduced BGPSec Keys
        """
        current_timestamp = datetime.now(timezone.utc).timestamp()

        reduced_bgpsec_keys: dict[str, BGPSecKey] = {}
        for bgpsec_key in bgpsec_keys:
            if current_timestamp >= bgpsec_key["expires"]:
                continue
            key = f'{bgpsec_key["asn"]}|{bgpsec_key["ski"]}|{bgpsec_key["pubkey"]}'
            reduced_bgpsec_keys[key] = bgpsec_key

        return reduced_bgpsec_keys

    def load_json_file(self) -> JSON:
        """
        Loads the content of the file. Remove expired ROAs and BGPSec Keys

        Returns:
        --------
        JSON: The JSON file
        """
        with open(self.json_file, mode="rb") as file:
            data: bytes = file.read()

        # This is not JSONContent yet, it will be after we convert ROAs, BGPSec Keys and ASPAS to
        # dictionaries
        try:
            json_content = orjson.loads(data)  # pylint: disable=no-member
        except orjson.JSONDecodeError as error:  # pylint: disable=no-member
            raise ValueError(f"Unable to decode the file: {error}") from error

        # Check if the file is expired
        buildtime = datetime.fromisoformat(json_content["metadata"]["buildtime"])
        expire_moment = buildtime + timedelta(seconds=self.expire)

        # Set values baseline
        roas: dict[str, ROA] = {}
        bgpsec_keys: dict[str, BGPSecKey] = {}
        aspas: dict[str, ASPA] = {}

        # Parse values
        if datetime.now(timezone.utc) > expire_moment:
            # The file is expired and so are VRPs, BGPSec Keys and ASPAs
            logger.warning("The JSON file is expired")
        else:
            match self.version:
                case 0:
                    # Parse ROAs and do not parse BGPSec Keys
                    roas = self._reduce_roas(json_content["roas"])
                case 1:
                    # Parse ROAs
                    roas = self._reduce_roas(json_content["roas"])
                    # Parse BGPSec Keys
                    bgpsec_keys = self._reduce_bgpsec_keys(json_content["bgpsec_keys"])
                case _:
                    raise ValueError(f"Unsupported version number: {self.version}")

        # Update JSON
        json_content["roas"] = roas
        json_content["bgpsec_keys"] = bgpsec_keys
        json_content["aspas"] = aspas

        # Calculate hash
        json_hash: str = str(
            hash(
                orjson.dumps(json_content["roas"], option=orjson.OPT_SORT_KEYS)
                + orjson.dumps(json_content["bgpsec_keys"], option=orjson.OPT_SORT_KEYS)
            )
        )

        return {
            "content": json_content,
            "hash": json_hash,
            "timestamp": buildtime.timestamp(),
            "diffs": {"vrps": [], "router_keys": []},
        }

    def reload(self) -> bool:
        """
        Purge old JSON files, load the new one, calculate diffs, and increment serial.

        Return:
        -------
        bool: True if the process completed successfully.
        """
        self.purge()

        new_json: JSON = self.load_json_file()

        # Check if the new and the current file are the same
        try:
            if new_json["hash"] == self.json[self.serial]["hash"]:
                return False
        except KeyError:
            pass

        # Calculate diffs
        for old_json in self.json.values():
            # Do not waste CPU cycles if not needed
            match self.version:
                case 0:
                    vrps = self.calculate_roa_diffs(
                        new_roas=new_json["content"]["roas"],
                        old_roas=old_json["content"]["roas"],
                    )
                    old_json["diffs"] = {"vrps": list(vrps), "router_keys": []}
                case 1:
                    vrps = self.calculate_roa_diffs(
                        new_roas=new_json["content"]["roas"],
                        old_roas=old_json["content"]["roas"],
                    )
                    router_keys = self.calculate_bgpsec_key_diffs(
                        new_bgpsec_keys=new_json["content"]["bgpsec_keys"],
                        old_bgpsec_keys=old_json["content"]["bgpsec_keys"],
                    )
                    old_json["diffs"] = {"vrps": list(vrps), "router_keys": list(router_keys)}
                case _:
                    raise ValueError(f"Unsupported version number: {self.version}")

        self.vrps = [self.serialize_vrp(vrp, 1) for vrp in new_json["content"]["roas"].values()]
        self.router_keys = [
            self.serialize_bgpsec_key(bgpsec_key, 1)
            for bgpsec_key in new_json["content"]["bgpsec_keys"].values()
        ]

        self.serial = self.serial + 1
        self.json[self.serial] = new_json

        self.update_prometheus()

        logger.info("Serial for version %d changed to: %d", self.version, self.serial)

        return True

    def update_prometheus(self, increment_serial: bool = True) -> None:
        """
        Updates the RPKI prometheus endpoints

        Arguments:
        ----------
        increment_serial: bool
            Whether to increment the metric for the serial counter of not. Defatul: True
        """
        match self.version:
            case 0:
                if increment_serial:
                    prometheus.rpki_v0_serial.inc()
                prometheus.rpki_v0_vrps.set(len(self.vrps))
                prometheus.rpki_v0_bgpsec_keys.set(len(self.router_keys))
            case 1:
                if increment_serial:
                    prometheus.rpki_v1_serial.inc()
                prometheus.rpki_v1_vrps.set(len(self.vrps))
                prometheus.rpki_v1_bgpsec_keys.set(len(self.router_keys))
            case _:
                logger.warning(
                    "Not exporting the RPKI serial counter for version: %d", self.version
                )
